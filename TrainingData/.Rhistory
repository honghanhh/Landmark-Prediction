P <- procrustes(U, "2.TPS")
X <- tps.process("1.TPS", type = "anole")
Y <- tps.process("2.TPS", type = "anole")
procrustes(X1, X2, translation = FALSE, dilation = FALSE)
X <- tps.process("1.TPS", type="anole")
X1 <- matrix(unlist(X), ncol = 2, byrow = TRUE)
Y <- tps.process("2.TPS", type="anole")
X2 <- matrix(unlist(X), ncol = 2, byrow = TRUE)
procrustes(X1, X2, translation = FALSE, dilation = FALSE)
X
X2
X1
X <- tps.process("1.TPS", type="anole")
X1 <- matrix(unlist(X), ncol = 2, byrow = TRUE)
Y <- tps.process("2.TPS", type="anole")
X2 <- matrix(unlist(X), ncol = 2, byrow = TRUE)
X1
X2
X
Y
X <- tps.process("1.TPS", type = "anole")
X1 <- matrix(unlist(X), ncol = 2, byrow = TRUE)
X1
Y <- tps.process("1.TPS", type = "anole")
X <- tps.process("1.TPS", type = "anole")
X1 <- matrix(unlist(X), ncol = 2, byrow = TRUE)
Y <- tps.process("2.TPS", type = "anole")
Y1 <- matrix(unlist(Y), ncol = 2, byrow = TRUE)
X1
Y1
procrustes(X1, Y1, translation = FALSE, dilation = FALSE)
getOption("repo")
if(!require(installr)) {
install.packages("installr");
require(installr)
}
updateR(htmltools)
update.packages(htmltools)
install.packages("rmarkdown")
install.packages("rmarkdown")
install.packages("htmltools 0.3.5")
install.packages("htmltools 0.2.6")
install.packages("knitr")
install.packages("htmltools")
getOption("repo")
updateR()
library("knitr", lib.loc="~/R/win-library/3.2")
library("htmltools", lib.loc="~/R/win-library/3.2")
getOption("repos")
updateR()
library("rmarkdown")
updateR()
library(Ã­ntallr)
library(installr)
updateR()
updateR()
install.packages("htmltool0.3.5")
version
install.packages("htmltool0.3.5")
install.packages("htmltool")
install.packages("knitr")
install.packages("htmltool")
install.packages("rmarkdown")
install.packages("rmarkdown1.2")
updateR()
library("installr")
updateR()
install.packages("htmltools")
install.packages("htmltools")
install.packages("htmltools")
install.packages("knitr")
install.packages("rmarkdown")
"C:/Program Files/RStudio/bin/pandoc/pandoc" +RTS -K512m -RTS testknitr.utf8.md --to latex --from markdown+autolink_bare_uris+ascii_identifiers+tex_math_single_backslash --output testknitr.pdf --template "C:\Users\Admin\Documents\R\win-library\3.3\rmarkdown\rmd\latex\default-1.17.0.2.tex" --highlight-style tango --latex-engine pdflatex --variable graphics=yes --variable "geometry:margin=1in"
gls(model, data, correlation, weights, subset, method, na.action,
control, verbose)
library(nlme)
gls(model, data, correlation, weights, subset, method, na.action,
control, verbose)
# AR(1) errors within each Mare
fm1 <- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
correlation = corAR1(form = ~ 1 | Mare))
# variance increases as a power of the absolute fitted values
fm2 <- update(fm1, weights = varPower())
fm1
fm2
#pull data out of the file and translate the scale
tps.process <- function(filename, type = c("general", "anole")) {
n <- length(filename)
X <- list()
type <- type[1]
for (i in 1:n) {
f <- filename[i]
lm <- as.numeric(strsplit(readLines(f, 1)[[1]], "=")[[1]][2])
X[[i]] <- read.table(f, skip = 1, nrows = lm)
id <- readLines(f, lm + 2)[[lm + 2]]
id <- strsplit(id, "=")[[1]][2]
id <- strsplit(id, ".t")[[1]][1]
names(X)[i] <- id
scale <- readLines(f, lm + 3)[[lm + 3]]
scale <- strsplit(scale, "=")[[1]]
j <- 1;
while (scale[1] != "SCALE") {
scale <- readLines(f, lm + 3 + j)[[lm + 3 + j]]
scale <- strsplit(scale, "=")[[1]]
}
scale <- as.numeric(scale[2])
X[[i]] <- X[[i]] * scale
X[[i]] <- X[[i]] - matrix(1, nrow(X[[i]]), 1) %*% matrix(apply(X[[i]], 2, min), 1, 2)
par(ask = FALSE)
plot(X[[i]], asp = 1)
if (type == "anole") {
lines(X[[i]][1:3,])
lines(X[[i]][c(1, 3),])
for (j in 2:21)
lines(X[[i]][(2 * j):(2 * j + 1),])
}
text(x = par()$usr[1], y = 0.95 * par()$usr[4], id, pos = 4)
readline(prompt = "OK? Press <Enter> to continue...")
}
return(X)
}
X <- tps.process("1.TPS", type = "anole")
Y <- tps.process("2.TPS", type = "anole")
gls(X1, data, correlation, weights, subset, method, na.action,
control, verbose)
glsControl(maxIter, msMaxIter, tolerance, msTol, msVerbose,
singular.ok, returnObject, apVar, .relStep,
opt=c("nlminb", "optim"), optimMethod,
minAbsParApVar, natural, sigma = NULL)
glsControl(maxIter=16, msMaxIter, tolerance, msTol, msVerbose = TRUE,singular.ok, returnObject, apVar, .relStep,
opt=c("nlminb", "optim"), optimMethod,
minAbsParApVar, natural, sigma = NULL)
library(nlme)
glsControl(maxIter=16, msMaxIter, tolerance, msTol, msVerbose = TRUE,singular.ok, returnObject, apVar, .relStep,
opt=c("nlminb", "optim"), optimMethod,
minAbsParApVar, natural, sigma = NULL)
glsControl(maxIter, msMaxIter=16, tolerance, msTol, msVerbose = TRUE,singular.ok, returnObject, apVar, .relStep,
opt=c("nlminb", "optim"), optimMethod,
minAbsParApVar, natural, sigma = NULL)
glsControl(maxIter=16, msMaxIter=16, tolerance, msTol, msVerbose = TRUE,singular.ok, returnObject, apVar, .relStep,
opt=c("nlminb", "optim"), optimMethod,
minAbsParApVar, natural, sigma = NULL)
glsControl(maxIter=16, msMaxIter=16, tolerance =1e-6, msTol, msVerbose = TRUE,singular.ok, returnObject, apVar, .relStep,
opt=c("nlminb", "optim"), optimMethod,
minAbsParApVar, natural, sigma = NULL)
glsControl(maxIter=50, msMaxIter=50, tolerance = 1e-6, msTol=1e-7, msVerbose = FALSE,
singular.ok = FALSE, returnObject=FALSE, apVar=TRUE, .relStep=.Machine$double.eps^(1/3),
opt=c("nlminb", "optim"), optimMethod = BFGS,
minAbsParApVar=0.05, natural=TRUE, sigma = NULL)
glsControl(maxIter=50, msMaxIter=50, tolerance = 1e-6, msTol=1e-7, msVerbose = FALSE,
singular.ok = FALSE, returnObject=FALSE, apVar=TRUE, .relStep=.Machine$double.eps^(1/3),
opt=c("nlminb", "optim"), optimMethod = "BFGS",
minAbsParApVar=0.05, natural=TRUE, sigma = NULL)
gls(X1, data, correlation, weights, subset, method, na.action,
control, verbose)
control(maxIter=50, msMaxIter=50, tolerance = 1e-6, msTol=1e-7, msVerbose = FALSE,
singular.ok = FALSE, returnObject=FALSE, apVar=TRUE, .relStep=.Machine$double.eps^(1/3),
opt=c("nlminb", "optim"), optimMethod = "BFGS",
minAbsParApVar=0.05, natural=TRUE, sigma = NULL)
glsControl(msMaxIter = 20, msVerbose = TRUE)
control(maxIter=50, msMaxIter=50, tolerance = 1e-6, msTol=1e-7, msVerbose = FALSE,
singular.ok = FALSE, returnObject=FALSE, apVar=TRUE, .relStep=.Machine$double.eps^(1/3),
opt=c("nlminb", "optim"), optimMethod = "BFGS",
minAbsParApVar=0.05, natural=TRUE, sigma = NULL)
glsControl(maxIter=50, msMaxIter=50, tolerance = 1e-6, msTol=1e-7, msVerbose = FALSE,
singular.ok = FALSE, returnObject=FALSE, apVar=TRUE, .relStep=.Machine$double.eps^(1/3),
opt=c("nlminb", "optim"), optimMethod = "BFGS",
minAbsParApVar=0.05, natural=TRUE, sigma = NULL)
gls(X1, data, correlation, weights, subset, method, na.action, verbose)
gls(X1, data, correlation, weights, subset, method, na.action, verbose =FALSE)
gls(X1~ mathematics, data, correlation, weights, subset, method, na.action,
control, verbose)
gls(X1~ mathematics, data, correlation, weights, subset, method, na.action,
control='', verbose)
gls(X1~ mathematics, data, correlation, weights, subset, method="REML", na.action,
control, verbose)
gls(X1~ mathematics, data, correlation, weights, subset, method="REML", na.action,
control="", verbose)
gls(X1~ mathematics, data, correlation = NULL, weights, subset, method="REML", na.action,
control="", verbose)
gls(X1~ mathematics, data, correlation = NULL, weights=NULL, subset, method="REML", na.action,
control="", verbose)
data
X <- tps.process("1.TPS", type = "anole")
X1 <- matrix(unlist(X), ncol = 2, byrow = TRUE)
gls(X1~ mathematics, X1, correlation = NULL, weights=NULL, subset, method="REML", na.action,
control="", verbose)
X1
library(ggvis)
library(shapes)
install.packages("ggvis")
library(ggvis)
library(shapes)
library(ggvis)
install.packages("shapes")
library(ggvis)
library(shapes)
standard <- read.csv(file="C:/Users/Admin/Documents/Intern/Intern/P-a sample/Standard .csv", header=TRUE, sep=" ")
data1 <- read.csv(file="C:/Users/Admin/Documents/Intern/Intern/P-a sample/1 .csv", header=TRUE, sep=" ")
cadidateData <- read.csv(file="C:/Users/Admin/Documents/Intern/Intern/P-a sample/Sample .csv", header=TRUE, sep=",")
standard <- read.csv(file="C:/Users/Admin/Documents/Intern/Intern/P-a sample/Standard .csv", header=TRUE, sep=" ")
standard <- read.csv(file="C:/Users/Admin/Documents/Intern/Intern/P-a sample/Standard .csv")
data1 <- read.csv(file="C:/Users/Admin/Documents/Intern/Intern/P-a sample/1 .csv")
cadidateData <- read.csv(file="C:/Users/Admin/Documents/Intern/Intern/P-a sample/Sample .csv")
cadidateData%>%ggvis(~X, ~Y, fill = ~type)
library("type")
install.packages("type")
cadidateData%>%ggvis(~X, ~Y, fill = ~type)
library(ggvis)
library(shapes)
#Load 3 shapes (standard, data1, cadidateData) from csv files
standard <- read.csv(file="C:/Users/Admin/Documents/Intern/Intern/P-a sample/Standard .csv")
data1 <- read.csv(file="C:/Users/Admin/Documents/Intern/Intern/P-a sample/1 .csv")
cadidateData <- read.csv(file="C:/Users/Admin/Documents/Intern/Intern/P-a sample/Sample .csv")
#Try plotting candidate points: true landmarks are blue while the others are black
cadidateData%>%ggvis(~X, ~Y)
library(ggvis)
library(shapes)
#Load 3 shapes (standard, data1, cadidateData) from csv files
standard <- read.csv(file="C:/Users/Admin/Documents/Intern/Intern/P-a sample/Standard .csv")
data1 <- read.csv(file="C:/Users/Admin/Documents/Intern/Intern/P-a sample/1 .csv")
cadidateData <- read.csv(file="C:/Users/Admin/Documents/Intern/Intern/P-a sample/Sample .csv")
#Try plotting candidate points: true landmarks are blue while the others are black
cadidateData%>%ggvis(~X, ~Y, fill = ~ID)
standard.m<-as.matrix(cbind(standard$X,standard$Y))
data1.m<-as.matrix(cbind(data1$X,data1$Y))
data1_p = procOPA(standard.m,data1.m)
plotshapes(standard.m,data1.m,joinline=1:16)
plotshapes(standard.m,data1_p$Bhat,joinline=1:16)
data(iris)
iris.rf <- randomForest(iris[,-5], iris[,5], prox=TRUE)
iris.p <- classCenter(iris[,-5], iris[,5], iris.rf$prox)
plot(iris[,3], iris[,4], pch=21, xlab=names(iris)[3], ylab=names(iris)[4],
bg=c("red", "blue", "green")[as.numeric(factor(iris$Species))],
main="Iris Data with Prototypes")
points(iris.p[,3], iris.p[,4], pch=21, cex=2, bg=c("red", "blue", "green"))
install.packages("RGeostats")
library(RGeostats)
install.packages("flexclust")
library(flexclust)
install.packages("flexclust")
library(ggvis)
library(shapes)
library(matlib)
library(rgeos)
library(plyr)
library(optR)
library(rpart)
library(rpart.plot)
library(randomForest)
library(e1071)
library(caret)
# library(rattle)
# library(help="randomForest")
setwd("C:/Users/Admin/Documents/Intern/Extract feature/TrainingData")
#setwd("C:/Users/Admin/Documents/Intern/Extract feature/H/TrainingData")
temp = list.files(pattern="*.csv")
#Function to calculate distance to bounding box
intersection_point  = function(a, data){
if ((data[[2]]-data[[1]]) != 0){
slope = (data[2,2] - data[1,2])/(data[[2]]-data[[1]])
c1 = - ((data[2,2] - slope*data[2,1]))
A <- matrix(c(1,slope,0,-1), nrow=2, ncol=2)
b <- matrix(cbind(a[1],c1), nrow=2, ncol=1)
Z1<-optR(A, b, method="gauss")
output1 <- matrix(unlist(Z1[3]), nrow=1 , ncol =2)
} else{
A <- matrix(c(1,0,0,-1), nrow=2, ncol=2)
b <- matrix(cbind(data[[1]],-a[2]), nrow=2, ncol=1)
Z1<-optR(A, b, method="gauss")
output1 <- matrix(unlist(Z1[3]), nrow=1 , ncol =2)
}
return(output1)
}
distanceToBoundary= function(a, b){
distance <- sqrt((b[1]- a[1])^2 + (b[2]-a[2])^2)
return(distance)
}
# initial data
temp1 = data.frame()
for (i in 1:length(temp)){
data = read.csv(temp[i], sep = ',', header = TRUE)
#calculate center
data1 <- data.matrix(cbind(data$X, data$Y))
colnames(data1) <- c("X", "Y")
center <- colMeans(data1)
a = data.frame()
for (j in 1:length(data1[,1])){
distance <- sqrt((data1[j,1]-center[1])^2 + (data1[j,2]-center[2])^2)
a <- rbind(a, distance)
}
colnames(a) <- c("Distance")
X <- cbind(data,a)
# initial 4 point of bounding box
up_left <- data.matrix(cbind(min(data$X), max(data$Y)))
down_left <- data.matrix(cbind(min(data$X), min(data$Y)))
up_right <- data.matrix(cbind(max(data$X), max(data$Y)))
down_right <- data.matrix(cbind(max(data$X), min(data$Y)))
temp_data = matrix(ncol=2)
temp_data = temp_data[-1,]
upper_boundary=rbind(up_left, up_right)
rownames(upper_boundary, do.NULL = FALSE)
rownames(upper_boundary) <- c("UP","")
temp_data = rbind(temp_data, upper_boundary)
lowwer_boundary=rbind(down_left, down_right)
rownames(lowwer_boundary, do.NULL = FALSE)
rownames(lowwer_boundary) <- c("DOWN","")
temp_data = rbind(temp_data, lowwer_boundary)
left_boundary=rbind(up_left, down_left)
rownames(left_boundary, do.NULL = FALSE)
rownames(left_boundary) <- c("LEFT","")
temp_data = rbind(temp_data, left_boundary)
right_boundary=rbind(up_right, down_right)
rownames(right_boundary, do.NULL = FALSE)
rownames(right_boundary) <- c("RIGHT","")
temp_data = rbind(temp_data, right_boundary)
# plot test
#test<- rbind(down_left, down_right,up_right, up_left, down_left)
#plotshapes(test, joinline=1:5)
#points(data1)
#calculate distance feature
output1 =  matrix(ncol=4, nrow=1)
output1 =  output1[-1,]
for (m in 1:length(data1[,1])){
point = data1[m,]
feature_output =  matrix(ncol=1, nrow=1)
feature_output =  feature_output[-1,]
for (k in 1:(nrow(temp_data))){
if(k%%2 != 0 ){
tempx <- data.matrix(temp_data[k:(k+1),])
inter_point <- intersection_point(point,tempx)
z <- data.matrix(inter_point)
temp5<-distanceToBoundary(point,z )
temp5 =  data.matrix(temp5)
rownames(temp5, do.NULL = FALSE)
rownames(temp5) <- c(row.names(temp_data)[k])
feature_output <- rbind(feature_output, temp5 )
}
}
output1 <- rbind(output1, t(feature_output))
}
#output
X <- cbind(X, output1)
output <-  X[,c("X","Y","isLandmark",colnames(a),colnames(output1)[1],colnames(output1)[2],colnames(output1)[3],colnames(output1)[4],
"SURFfeature1","SURFfeature2","SURFfeature3","SURFfeature4","SURFfeature5","SURFfeature6","SURFfeature7","SURFfeature8",
"SURFfeature9","SURFfeature10","SURFfeature11","SURFfeature12","SURFfeature13","SURFfeature14","SURFfeature15","SURFfeature16",
"SURFfeature17","SURFfeature18","SURFfeature19","SURFfeature20","SURFfeature21","SURFfeature22","SURFfeature23","SURFfeature24",
"SURFfeature25","SURFfeature26","SURFfeature27","SURFfeature28","SURFfeature29","SURFfeature30","SURFfeature31","SURFfeature32",
"SURFfeature33","SURFfeature34","SURFfeature35","SURFfeature36","SURFfeature37","SURFfeature38","SURFfeature39","SURFfeature40",
"SURFfeature41","SURFfeature42","SURFfeature43","SURFfeature44","SURFfeature45","SURFfeature46","SURFfeature47","SURFfeature48",
"SURFfeature49","SURFfeature50","SURFfeature51","SURFfeature52","SURFfeature53","SURFfeature54","SURFfeature55","SURFfeature56",
"SURFfeature57","SURFfeature58","SURFfeature59","SURFfeature60","SURFfeature61","SURFfeature62","SURFfeature63","SURFfeature64",
"BRISKfeature1","BRISKfeature2","BRISKfeature3","BRISKfeature4","BRISKfeature5","BRISKfeature6","BRISKfeature7","BRISKfeature8",
"BRISKfeature9","BRISKfeature10","BRISKfeature11","BRISKfeature12","BRISKfeature13","BRISKfeature14","BRISKfeature15",
"BRISKfeature16","BRISKfeature17","BRISKfeature18","BRISKfeature19","BRISKfeature20","BRISKfeature21","BRISKfeature22",
"BRISKfeature23","BRISKfeature24","BRISKfeature25","BRISKfeature26","BRISKfeature27","BRISKfeature28","BRISKfeature29",
"BRISKfeature30","BRISKfeature31","BRISKfeature32","BRISKfeature33","BRISKfeature34","BRISKfeature35","BRISKfeature36",
"BRISKfeature37","BRISKfeature38","BRISKfeature39","BRISKfeature40","BRISKfeature41","BRISKfeature42","BRISKfeature43",
"BRISKfeature44","BRISKfeature45","BRISKfeature46","BRISKfeature47","BRISKfeature48","BRISKfeature49","BRISKfeature50",
"BRISKfeature51","BRISKfeature52","BRISKfeature53","BRISKfeature54","BRISKfeature55","BRISKfeature56","BRISKfeature57",
"BRISKfeature58","BRISKfeature59","BRISKfeature60","BRISKfeature61","BRISKfeature62","BRISKfeature63","BRISKfeature64",
"HOGfeature1","HOGfeature2","HOGfeature3","HOGfeature4","HOGfeature5","HOGfeature6","HOGfeature7","HOGfeature8","HOGfeature9",
"HOGfeature10","HOGfeature11","HOGfeature12","HOGfeature13","HOGfeature14","HOGfeature15","HOGfeature16","HOGfeature17","HOGfeature18",
"HOGfeature19","HOGfeature20","HOGfeature21","HOGfeature22","HOGfeature23","HOGfeature24","HOGfeature25","HOGfeature26","HOGfeature27",
"HOGfeature28","HOGfeature29","HOGfeature30","HOGfeature31","HOGfeature32","HOGfeature33","HOGfeature34","HOGfeature35","HOGfeature36",
"FREAKfeature1","FREAKfeature2","FREAKfeature3","FREAKfeature4","FREAKfeature5","FREAKfeature6","FREAKfeature7","FREAKfeature8",
"FREAKfeature9","FREAKfeature10","FREAKfeature11","FREAKfeature12","FREAKfeature13","FREAKfeature14","FREAKfeature15",
"FREAKfeature16","FREAKfeature17","FREAKfeature18","FREAKfeature19","FREAKfeature20","FREAKfeature21","FREAKfeature22",
"FREAKfeature23","FREAKfeature24","FREAKfeature25","FREAKfeature26","FREAKfeature27","FREAKfeature28","FREAKfeature29",
"FREAKfeature30","FREAKfeature31","FREAKfeature32","FREAKfeature33","FREAKfeature34","FREAKfeature35","FREAKfeature36",
"FREAKfeature37","FREAKfeature38","FREAKfeature39","FREAKfeature40","FREAKfeature41","FREAKfeature42","FREAKfeature43",
"FREAKfeature44","FREAKfeature45","FREAKfeature46","FREAKfeature47","FREAKfeature48","FREAKfeature49","FREAKfeature50",
"FREAKfeature51","FREAKfeature52","FREAKfeature53","FREAKfeature54","FREAKfeature55","FREAKfeature56","FREAKfeature57",
"FREAKfeature58","FREAKfeature59","FREAKfeature60","FREAKfeature61","FREAKfeature62","FREAKfeature63","FREAKfeature64")]
#merge data
temp1 = rbind(temp1, output)
}
d <- temp1[,c("X","Y","isLandmark","Distance","UP","DOWN","LEFT","RIGHT")]
names(d)
str(d)
table(d$isLandmark)/nrow(d)
x <- subset(d, select=-isLandmark)
d$isLandmark <- factor(d$isLandmark)
y <- d$isLandmark
svm_model1 <- svm(x,y)
summary(svm_model1)
summary(svm_model1)
pred <- predict(svm_model1,x)
pred
system.time(pred <- predict(svm_model1,x))
table(pred,y)
svm_tune <- tune(svm, train.x=x, train.y=y, kernel="radial", ranges=list(cost=10^(-1:2), gamma=c(.5,1,2)))
print(svm_tune)
x <- subset(d, select=-isLandmark)
head(x)
d$isLandmark <- factor(d$isLandmark)
str(d$isLandmark)
x <- subset(d, select=-isLandmark)
d$isLandmark <- as.character(d$isLandmark)
d$isLandmark <- as.factor(d$isLandmark)
str(d$isLandmark)
x <- subset(d, select=-isLandmark)
y <- d$isLandmark
y
y <- as.factor(y)
str(y)
svm_model1 <- svm(x,y)
summary(svm_model1)
pred <- predict(svm_model1,x)
pred
system.time(pred <- predict(svm_model1,x))
table(pred,y)
svm_model1 <- svm(x,y)
svm_model1
x <- subset(d, select=-isLandmark)
head(x)
y <- d$isLandmark
y <- as.factor(y)
svm_model1 <- svm(x,y)
summary(svm_model1)
pred <- predict(svm_model1,x)
system.time(pred <- predict(svm_model1,x))
table(pred,y)
svm_model1 <- svm(x,y)
svm_model1
d <- as.factor(d)
d <- as.character(d)
d <- as.factor(d)
head(d)
d <- temp1[,c("X","Y","isLandmark","Distance","UP","DOWN","LEFT","RIGHT")]
head(d)
head(iris)
str(iris$Species)
str(iris$Petal.Length)
str(iris$Petal.Width)
head(d)
str(d$XX)
str(d$X)
str(d$Y)
str(d$Distance)
x <- subset(d, select=-isLandmark)
X
head(X)
head(d)
x <- subset(d, select=-isLandmark)
head(x)
y <- as.factor(y)
head(y)
y <- as.factor(y)
head(I)
head(y)
svm_model1 <- svm(x,y)
summary(svm_model1)
pred <- predict(svm_model1,x)
pred
system.time(pred <- predict(svm_model1,x))
x <- subset(d, select=-isLandmark)
y <- d$isLandmark
head(y)
y -> as.character(y)
y <- as.character(y)
y <- as.factor(y)
y
svm_model1 <- svm(x,y)
summary(svm_model1)
pred <- predict(svm_model1,x)
system.time(pred <- predict(svm_model1,x))
pred
table(pred,y)
x <- subset(d, select=-isLandmark)
y <- d$isLandmark
head(X)
head(d)
x <- subset(d, select=-isLandmark)
head(x)
y <- d$isLandmark
y <- as.factor(y)
svm_model1 <- svm(x,y)
summary(svm_model1)
pred
y
svm_model1 <- svm(x,y)
svm_model1
x <- subset(d, select=-isLandmark)
x
y <- d$isLanxdmark
y
y <- d$isLandmark
x
y
dat <- data.frame(x=x, y=as.factor(y))
dat
plot(svm.fit, dat)
library(e1071)
plot(svm.fit, dat)
plot(svm.fit)
svm.fit <- svm(y ~., data=dat, kernel='linear', cost=10, scale=FALSE)
dat <- data.frame(x=x, y=as.factor(y))
plot(x,col=y)
svm.fit <- svm(y ~., data=dat, kernel='radial', gamma=1, cost=1)
une.out <- tune(svm, y ~., data=dat[train,],
kernel='radial',
ranges = list(cost=c(0.1,1,10,100,1000),
gamma=c(0.5, 1,2,3,4)))
tune.out <- tune(svm, y ~., data=dat[train,],
kernel='radial',
ranges = list(cost=c(0.1,1,10,100,1000),
gamma=c(0.5, 1,2,3,4)))
tune.out <- tune(svm, y ~., data=dat,
kernel='radial',
ranges = list(cost=c(0.1,1,10,100,1000),
gamma=c(0.5, 1,2,3,4)))
